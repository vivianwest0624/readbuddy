<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ReadBuddyï½œæœ—è®€å¤¥ä¼´</title>
    <!-- Tailwind CDN for quick styling (Route A: zero-build) -->
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="min-h-screen bg-slate-50">
    <div id="root"></div>

    <!-- React 18 UMD + Babel (to run JSX directly in the browser) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel" data-presets="env,react" data-plugins="proposal-optional-chaining,proposal-nullish-coalescing-operator">
      // ========================
      // ReadBuddyï½œæœ—è®€å¤¥ä¼´ (Route A)
      // Change request:
      // - Merge "å¾é¸å–æ–°å¢" & "å¾é¸å–æ–°å¢ï¼ˆAIï¼‰" into ONE button/function.
      // - When adding from selection, also save the article (content + updated vocab) together.
      // ========================

      // ----- Constants -----
      const RATE_MIN = 0.25;
      const RATE_MAX = 2.0;
      const RATE_ABS_MAX = 2.5;
      const ARTICLES_KEY = 'rb_articles_v2'; // stores vocab in each article
      const AI_PROVIDER_KEY = 'rb_ai_provider';
      const AI_KEY_KEY = 'rb_ai_key';
      const AI_MODEL_KEY = 'rb_ai_model';

      function App() {
        // ---------- Safe storage helpers ----------
        const storage = React.useMemo(
          () => ({
            get(key, fallback = "") {
              try {
                if (typeof localStorage === "undefined") return fallback;
                const v = localStorage.getItem(key);
                return v == null ? fallback : v;
              } catch (_) {
                return fallback;
              }
            },
            set(key, value) {
              try {
                if (typeof localStorage !== "undefined") localStorage.setItem(key, value);
              } catch (_) {}
            },
          }),
          []
        );

        // ---------- State ----------
        const [text, setText] = React.useState("");
        const [rate, setRate] = React.useState(() => {
          const saved = parseFloat(storage.get("tts_rate", "1.0"));
          return Number.isFinite(saved) ? saved : 1.0;
        });
        const [voices, setVoices] = React.useState([]);
        const [voiceURI, setVoiceURI] = React.useState(() => storage.get("tts_voiceURI", ""));
        const [status, setStatus] = React.useState("idle"); // idle | speaking | paused
        const [currentIndex, setCurrentIndex] = React.useState(-1);
        const queueRef = React.useRef([]);
        const cancelledRef = React.useRef(false);
        const chunkRefs = React.useRef([]);
        const modeRef = React.useRef('idle'); // 'idle' | 'article' | 'vocab'
        const rateChangeTimerRef = React.useRef(null);
        const charIndexRef = React.useRef(0);
        const pendingCharOffsetRef = React.useRef(0);
        const pendingResumeIndexRef = React.useRef(null);

        // Vocabulary state
        const [vocab, setVocab] = React.useState(() => {
          try {
            const raw = storage.get("tts_vocab", "[]");
            const arr = JSON.parse(raw);
            return Array.isArray(arr) ? arr : [];
          } catch {
            return [];
          }
        });

        // Articles state (each article holds its own content + vocab)
        const [articles, setArticles] = React.useState(() => {
          try {
            const rawNew = storage.get(ARTICLES_KEY, null);
            if (rawNew) {
              const arr = JSON.parse(rawNew);
              return Array.isArray(arr) ? arr : [];
            }
            const rawOld = storage.get('rb_articles', '[]');
            const oldArr = JSON.parse(rawOld);
            return Array.isArray(oldArr) ? oldArr : [];
          } catch {
            return [];
          }
        });
        const [articleId, setArticleId] = React.useState(null); // null = new
        const [articleTitle, setArticleTitle] = React.useState("");

        // AI config
        const [aiProvider, setAiProvider] = React.useState(() => storage.get(AI_PROVIDER_KEY, 'none') || 'none');
        const [aiKey, setAiKey] = React.useState(() => storage.get(AI_KEY_KEY, ''));
        const [aiModel, setAiModel] = React.useState(() => storage.get(AI_MODEL_KEY, 'gpt-4o-mini'));
        const [defLoading, setDefLoading] = React.useState(false);
        const [notice, setNotice] = React.useState('');

        // ---------- Env feature detection ----------
        const supported = typeof window !== "undefined" && "speechSynthesis" in window && typeof SpeechSynthesisUtterance !== "undefined";

        // ---------- Effects: load / persist ----------
        React.useEffect(() => { const savedText = storage.get("tts_text", ""); if (savedText) setText(savedText); }, [storage]);
        React.useEffect(() => { storage.set("tts_rate", String(rate)); }, [rate, storage]);
        React.useEffect(() => { if (voiceURI) storage.set("tts_voiceURI", voiceURI); }, [voiceURI, storage]);
        React.useEffect(() => { storage.set("tts_text", text); }, [text, storage]);
        React.useEffect(() => { try { storage.set("tts_vocab", JSON.stringify(vocab)); } catch {} }, [vocab, storage]);
        React.useEffect(() => { try { storage.set(ARTICLES_KEY, JSON.stringify(articles)); } catch {} }, [articles, storage]);
        React.useEffect(() => { storage.set(AI_PROVIDER_KEY, aiProvider); }, [aiProvider, storage]);
        React.useEffect(() => { if (aiKey) storage.set(AI_KEY_KEY, aiKey); }, [aiKey, storage]);
        React.useEffect(() => { storage.set(AI_MODEL_KEY, aiModel || 'gpt-4o-mini'); }, [aiModel, storage]);

        // ---------- Voices loader ----------
        const loadVoices = React.useCallback(() => {
          if (!supported) return;
          const list = window.speechSynthesis.getVoices();
          setVoices(list);
          if (!voiceURI && list.length) {
            const prefer = list.find((v) => /zh-TW/i.test(v.lang)) || list.find((v) => /zh-CN/i.test(v.lang)) || list.find((v) => /en-US/i.test(v.lang)) || list[0];
            if (prefer) setVoiceURI(prefer.voiceURI || prefer.name);
          }
        }, [supported, voiceURI]);

        React.useEffect(() => {
          if (!supported) return;
          loadVoices();
          window.speechSynthesis.onvoiceschanged = loadVoices;
          return () => { if (window.speechSynthesis) window.speechSynthesis.onvoiceschanged = null; };
        }, [supported, loadVoices]);

        // ---------- Utils ----------
        function countWords(t) {
          const latin = (t.match(/\S+/g) || []).length;
          const cjk = t.replace(/[\x00-\x7F]/g, "").length / 2;
          return Math.max(latin, Math.round(cjk));
        }
        function estimateDuration(txt, r) {
          const words = countWords(txt);
          const baseWPM = 160; if (!words) return "0:00";
          const minutes = words / (baseWPM * Math.max(r, RATE_MIN));
          const totalSec = Math.ceil(minutes * 60);
          const mm = Math.floor(totalSec / 60);
          const ss = String(totalSec % 60).padStart(2, "0");
          return `${mm}:${ss}`;
        }
        function splitIntoChunks(t) {
          const parts = [];
          const tokens = t.split(/([ã€‚ï¼ï¼Ÿ!?.\n]+)/).reduce((acc, cur) => {
            if (/[ã€‚ï¼ï¼Ÿ!?.\n]+/.test(cur) && acc.length) acc[acc.length - 1] += cur; else if (cur.trim()) acc.push(cur.trim());
            return acc;
          }, []);
          const MAX_LEN = 180;
          for (const s of tokens) {
            if (s.length <= MAX_LEN) parts.push(s); else {
              let start = 0;
              while (start < s.length) {
                let end = Math.min(start + MAX_LEN, s.length);
                const slice = s.slice(start, end);
                const back = Math.max(slice.lastIndexOf(" "), slice.search(/[ï¼Œã€,;ï¼›]/) >= 0 ? slice.search(/[ï¼Œã€,;ï¼›](?!.*[ï¼Œã€,;ï¼›])/) : -1);
                if (back > 40) end = start + back + 1;
                parts.push(s.slice(start, end).trim());
                start = end;
              }
            }
          }
          return parts;
        }
        const getSelectedVoice = React.useCallback(() => voices.find((v) => (v.voiceURI || v.name) === voiceURI) || null, [voices, voiceURI]);
        const chunks = React.useMemo(() => splitIntoChunks(text.trim()), [text]);
        React.useEffect(() => { chunkRefs.current = chunks.map((_, i) => chunkRefs.current[i] || React.createRef()); }, [chunks.length]);
        React.useEffect(() => {
          if (currentIndex < 0) return;
          var refObj = chunkRefs.current[currentIndex];
          var el = refObj && refObj.current;
          if (el && typeof el.scrollIntoView === "function") {
            el.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        }, [currentIndex]);

        // ---------- Article helpers ----------
        const saveArticleWithVocab = (nextVocab) => {
          const now = new Date().toISOString();
          const title = (articleTitle || '').trim() || new Date().toLocaleString();
          if (!articleId) {
            const id = Date.now() + Math.random().toString(36).slice(2);
            const item = { id, title, content: text, vocab: [...nextVocab], createdAt: now, updatedAt: now };
            setArticles((prev) => [item, ...prev]);
            setArticleId(id);
            setArticleTitle(title);
          } else {
            setArticles((prev) => prev.map((a) => a.id === articleId ? { ...a, title, content: text, vocab: [...nextVocab], updatedAt: now } : a));
          }
        };

        const createArticle = () => saveArticleWithVocab(vocab);
        const updateArticle = () => saveArticleWithVocab(vocab);
        const loadArticle = (id) => {
          const a = articles.find((x) => x.id === id); if (!a) return;
          setArticleId(a.id); setArticleTitle(a.title); setText(a.content || ""); setVocab(Array.isArray(a.vocab) ? a.vocab : []);
        };
        const removeArticle = (id) => {
          setArticles((prev) => prev.filter((x) => x.id !== id));
          if (id === articleId) { setArticleId(null); setArticleTitle(""); setText(""); setVocab([]); }
        };
        const newArticle = () => { setArticleId(null); setArticleTitle(""); setText(""); setVocab([]); };
        const renameArticle = (id) => {
          const a = articles.find((x) => x.id === id); if (!a) return;
          const nv = prompt('é‡æ–°å‘½åæ–‡ç« æ¨™é¡Œ', a.title); if (nv == null) return;
          const title = nv.trim(); if (!title) return;
          const now = new Date().toISOString();
          setArticles((prev) => prev.map((x) => x.id === id ? { ...x, title, updatedAt: now } : x));
          if (id === articleId) setArticleTitle(title);
        };

        // ---------- Selection â†’ Vocab (Unified, with AI and auto-save) ----------
        const sanitizeTerm = (s) => (s || '')
          .replace(/[\n\r\t]+/g, ' ')
          .replace(/^\s+|\s+$/g, '')
          .replace(/^[^A-Za-z0-9\u4e00-\u9fff]+/, '')
          .replace(/[^A-Za-z0-9\u4e00-\u9fff\-â€™' ]+$/, '')
          .slice(0, 64);
        const getSelectedFromTextarea = () => {
          const ta = document.getElementById('tts-text'); if (!ta) return '';
          const { selectionStart: s, selectionEnd: e } = ta; if (typeof s === 'number' && typeof e === 'number' && e > s) return ta.value.substring(s, e); return '';
        };
        const getSelectedFromWindow = () => { const sel = window.getSelection && window.getSelection(); return sel ? String(sel.toString()) : ''; };

        async function addSelectedUnified() {
          const raw = getSelectedFromTextarea() || getSelectedFromWindow();
          const term = sanitizeTerm(raw);
          if (!term) { setNotice('è«‹å…ˆåœ¨æ–‡ç« ç·¨è¼¯æ¡†æˆ–é è¦½å€é¸å–å–®å­—/ç‰‡èª'); return; }
          setNotice(''); setDefLoading(true);
          try {
            const def = await generateDefinition(term);
            // compute next vocab first
            let nextVocab;
            setVocab((prev) => {
              const exists = prev.some((x) => x.term.toLowerCase() === term.toLowerCase());
              nextVocab = exists ? prev.map((x) => (x.term.toLowerCase() === term.toLowerCase() ? { ...x, definition: def || x.definition } : x)) : [...prev, { id: Date.now() + Math.random().toString(36).slice(2), term, definition: def || '' }];
              return nextVocab;
            });
            // also save article snapshot with updated vocab
            saveArticleWithVocab(nextVocab || vocab);
            setNotice(`å·²åŠ å…¥ä¸¦å„²å­˜ï¼š${term}${def ? 'ï¼ˆå«è§£é‡‹ï¼‰' : 'ï¼ˆç„¡è§£é‡‹ï¼‰'}`);
          } catch (e) {
            console.error(e);
            // fallback: add without definition
            let nextVocab;
            setVocab((prev) => {
              const exists = prev.some((x) => x.term.toLowerCase() === term.toLowerCase());
              nextVocab = exists ? prev : [...prev, { id: Date.now() + Math.random().toString(36).slice(2), term, definition: '' }];
              return nextVocab;
            });
            saveArticleWithVocab(nextVocab || vocab);
            setNotice(`å·²åŠ å…¥ä¸¦å„²å­˜ï¼š${term}ï¼ˆAI è§£æå¤±æ•—ï¼Œå…ˆåŠ å…¥å–®å­—ï¼‰`);
          } finally {
            setDefLoading(false);
          }
        }

        async function generateDefinition(term) {
          // 1) Prefer OpenAI if configured
          if (aiProvider === 'openai' && aiKey) {
            try {
              const resp = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${aiKey}` },
                body: JSON.stringify({
                  model: aiModel || 'gpt-4o-mini', temperature: 0.2,
                  messages: [
                    { role: 'system', content: 'You are a concise bilingual dictionary. Reply in Traditional Chinese with part of speech and one short example. Keep under 25 words.' },
                    { role: 'user', content: `Define: ${term}` }
                  ],
                }),
              });
              if (!resp.ok) throw new Error('OpenAI API error');
              const data = await resp.json();
              const choice = data && data.choices && data.choices[0];
              const txt = choice && choice.message && choice.message.content ? String(choice.message.content).trim() : "";
              if (txt) return txt;
            } catch (e) { console.warn('OpenAI error', e); }
          }
          // 2) Fallback: Free Dictionary API (English only)
          try {
            const r = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(term)}`);
            if (r.ok) {
              const j = await r.json();
              const first = Array.isArray(j) ? j[0] : null;
              const meanings = first && first.meanings;
              const m0 = Array.isArray(meanings) ? meanings[0] : null;
              const defs = m0 && m0.definitions;
              const d0 = Array.isArray(defs) && defs[0] ? defs[0].definition : null;
              const pos = m0 && m0.partOfSpeech ? `(${m0.partOfSpeech}) ` : '';
              if (d0) return `${pos}${d0}`;
            }
          } catch (e) { console.warn('DictAPI error', e); }
          return '';
        }

        // ---------- Live rate change (hot apply) ----------
        function handleRateChange(newRate) {
          const clamped = Math.min(Math.max(newRate, RATE_MIN), RATE_MAX);
          setRate(clamped);
          if (!supported) return;
          if (status === 'speaking') {
            if (modeRef.current === 'article') {
              if (rateChangeTimerRef.current) clearTimeout(rateChangeTimerRef.current);
              rateChangeTimerRef.current = setTimeout(() => {
                try { window.speechSynthesis.cancel(); } catch (_) {}
                cancelledRef.current = false;
                const startAt = currentIndex >= 0 ? currentIndex : 0;
                const charAt = charIndexRef.current || 0;
                setTimeout(() => speakFromIndex(startAt, charAt), 0);
              }, 120);
            }
          } else if (status === 'paused') {
            if (modeRef.current === 'article') {
              try { window.speechSynthesis.cancel(); } catch (_) {}
              pendingResumeIndexRef.current = currentIndex >= 0 ? currentIndex : 0;
              pendingCharOffsetRef.current = charIndexRef.current || 0;
              setStatus('paused');
            }
          }
        }

        // ---------- TTS controls ----------
        function cancelAll() { if (!supported) return; cancelledRef.current = true; try { window.speechSynthesis.cancel(); } catch (_) {} queueRef.current = []; modeRef.current = 'idle'; pendingResumeIndexRef.current = null; setStatus("idle"); setCurrentIndex(-1); }
        function speakFromIndex(startIndex = 0, charOffset = 0) {
          if (!supported || !text.trim()) return;
          cancelAll();
          cancelledRef.current = false;
          modeRef.current = 'article';
          queueRef.current = chunks;
          const voice = getSelectedVoice();
          const clamp = (x) => Math.min(Math.max(x, RATE_MIN), RATE_ABS_MAX);

          const speakChunk = (i, offset) => {
            if (cancelledRef.current) return;
            if (i >= queueRef.current.length) { setStatus("idle"); setCurrentIndex(-1); return; }
            let chunkText = String(queueRef.current[i] || "");
            if (offset && offset > 0) {
              if (offset >= chunkText.length) { speakChunk(i + 1, 0); return; }
              chunkText = chunkText.slice(offset);
            }
            const utter = new SpeechSynthesisUtterance(chunkText);
            if (voice) utter.voice = voice;
            utter.rate = clamp(rate);
            utter.pitch = 1.0;
            utter.onstart = () => { setStatus("speaking"); setCurrentIndex(i); charIndexRef.current = offset || 0; };
            utter.onboundary = (ev) => { if (typeof ev.charIndex === 'number') { charIndexRef.current = (offset || 0) + ev.charIndex; } };
            utter.onend = () => { charIndexRef.current = 0; setTimeout(() => speakChunk(i + 1, 0), 20); };
            utter.onerror = () => { charIndexRef.current = 0; setTimeout(() => speakChunk(i + 1, 0), 20); };
            window.speechSynthesis.speak(utter);
          };
          speakChunk(startIndex, charOffset || 0);
        }

        
        function speak() { speakFromIndex(0); }
        function pause() { if (!supported) return; window.speechSynthesis.pause(); setStatus("paused"); }
        function resume() {
          if (!supported) return;
          if (window.speechSynthesis.speaking) {
            try { window.speechSynthesis.resume(); } catch (_) {}
            setStatus("speaking");
          } else {
            const idx = pendingResumeIndexRef.current != null ? pendingResumeIndexRef.current : (currentIndex >= 0 ? currentIndex : 0);
            const off = pendingCharOffsetRef.current || 0;
            pendingResumeIndexRef.current = null;
            pendingCharOffsetRef.current = 0;
            speakFromIndex(idx, off);
          }
        }

        // ---------- Vocabulary playback helpers ----------
        function speakTextsSequence(texts) {
          if (!supported || !texts.length) return;
          cancelAll();
          cancelledRef.current = false;
          modeRef.current = 'vocab';
          const voice = getSelectedVoice();
          let i = -1;
          const next = () => {
            if (cancelledRef.current) return;
            i += 1;
            if (i >= texts.length) { setStatus("idle"); return; }
            const u = new SpeechSynthesisUtterance(texts[i]); if (voice) u.voice = voice; u.rate = Math.min(Math.max(rate, RATE_MIN), RATE_ABS_MAX); u.pitch = 1.0;
            u.onstart = () => { setStatus("speaking"); setCurrentIndex(-1); }; u.onend = () => setTimeout(next, 120); u.onerror = () => setTimeout(next, 120);
            window.speechSynthesis.speak(u);
          };
          next();
        }
        function playWord(term, times = 3, withDefinition = false, definition = "") { const texts = []; for (let i = 0; i < times; i++) { texts.push(term); if (withDefinition && definition) texts.push(definition); } speakTextsSequence(texts); }
        function playAllWords(times = 2, withDefinition = false) { const texts = []; vocab.forEach((it) => { for (let i = 0; i < times; i++) { texts.push(it.term); if (withDefinition && it.definition) texts.push(it.definition); } }); speakTextsSequence(texts); }

        function addVocab(term, definition) {
          const t = (term || '').trim(); const d = (definition || '').trim(); if (!t) return false;
          setVocab((prev) => {
            const exists = prev.some((x) => x.term.toLowerCase() === t.toLowerCase());
            if (exists) return prev.map((x) => (x.term.toLowerCase() === t.toLowerCase() ? { ...x, definition: d || x.definition } : x));
            return [...prev, { id: Date.now() + Math.random().toString(36).slice(2), term: t, definition: d }];
          });
          return true;
        }
        function removeVocab(id) { setVocab((prev) => prev.filter((x) => x.id !== id)); }

        // ---------- Derived ----------
        const isSpeaking = status === "speaking";
        const isPaused = status === "paused";
        const est = estimateDuration(text, rate);
        const selectedVoice = getSelectedVoice();

        // ---------- UI ----------
        return (
          <div className="min-h-screen bg-gradient-to-b from-slate-50 to-slate-100 text-slate-800">
            <div className="max-w-6xl mx-auto p-6">
              <header className="flex items-center justify-between mb-6">
                <h1 className="text-2xl md:text-3xl font-semibold tracking-tight">ReadBuddyï½œæœ—è®€å¤¥ä¼´</h1>
                <div className="text-sm text-slate-500">Web Speech API TTS</div>
              </header>

              {!supported && (
                <div className="p-4 rounded-xl bg-red-50 text-red-700 border border-red-200 mb-6">
                  ä½ çš„ç€è¦½å™¨ç›®å‰ä¸æ”¯æ´èªéŸ³åˆæˆï¼ˆSpeechSynthesisï¼‰ã€‚å»ºè­°ä½¿ç”¨ Chrome / Edgeï¼ˆæ¡Œé¢ç‰ˆï¼‰ã€‚
                </div>
              )}

              {/* Main layout */}
              <div className="grid gap-4 md:grid-cols-3">
                {/* Left: Input + Preview + Articles */}
                <div className="md:col-span-2">
                  <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-4">
                    {/* Article Title & Actions */}
                    <div className="mb-3 grid grid-cols-1 md:grid-cols-3 gap-2 items-center">
                      <div className="md:col-span-2">
                        <label className="block text-sm font-medium mb-1" htmlFor="article-title">æ–‡ç« æ¨™é¡Œ</label>
                        <input id="article-title" value={articleTitle} onChange={(e) => setArticleTitle(e.target.value)} placeholder="æœªå‘½åæ–‡ç« " className="w-full rounded-xl border border-slate-300 p-2 bg-slate-50/50 focus:outline-none focus:ring-2 focus:ring-indigo-400" />
                      </div>
                      <div className="flex gap-2 md:justify-end flex-wrap">
                        <button onClick={updateArticle} className="px-3 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700">ğŸ’¾ å„²å­˜</button>
                        <button onClick={newArticle} className="px-3 py-2 rounded-xl bg-slate-100 hover:bg-slate-200">ğŸ“ æ–°æ–‡ç« </button>
                        </div>
                    </div>

                    {/* Articles list */}
                    <div className="mb-3">
                      <div className="flex items-center justify-between mb-1">
                        <h3 className="text-sm font-medium">æˆ‘çš„æ–‡ç« </h3>
                        <span className="text-xs text-slate-500">{articles.length} ç¯‡</span>
                      </div>
                      <div className="max-h-36 overflow-auto divide-y divide-slate-200 rounded-xl border border-slate-200 bg-slate-50">
                        {articles.length === 0 ? (
                          <div className="p-3 text-sm text-slate-500">å°šæœªå„²å­˜ä»»ä½•æ–‡ç« ã€‚è¼¸å…¥æ¨™é¡Œèˆ‡å…§å®¹å¾ŒæŒ‰ã€Œå„²å­˜ã€ã€‚</div>
                        ) : (
                          articles.map((a) => (
                            <div key={a.id} className={`p-2 flex items-center gap-2 ${a.id === articleId ? 'bg-indigo-50' : 'bg-white'}`}>
                              <button className="flex-1 text-left truncate" onClick={() => loadArticle(a.id)} title={new Date(a.updatedAt).toLocaleString()}>
                                <div className="font-medium truncate">{a.title}</div>
                                <div className="text-xs text-slate-500">æ›´æ–°ï¼š{new Date(a.updatedAt).toLocaleString()} Â· å–®å­— {Array.isArray(a.vocab) ? a.vocab.length : 0}</div>
                              </button>
                              <button className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200 text-xs" onClick={() => renameArticle(a.id)}>é‡æ–°å‘½å</button>
                              <button className="px-2 py-1 rounded bg-red-50 hover:bg-red-100 text-xs text-red-700 border border-red-200" onClick={() => removeArticle(a.id)}>åˆªé™¤</button>
                            </div>
                          ))
                        )}
                      </div>
                    </div>

                    {/* Editor */}
                    <div className="flex items-center justify-between mb-2">
                      <label htmlFor="tts-text" className="font-medium">è¼¸å…¥æ–‡å­—</label>
                      <div className="text-xs text-slate-500">{text.length} å­— Â· é ä¼° {est}</div>
                    </div>
                    <textarea id="tts-text" value={text} onChange={(e) => setText(e.target.value)} onDoubleClick={() => addSelectedUnified()} onKeyDown={(e) => { if (e.key === 'Enter') { const ta = e.target; const s = ta.selectionStart; const en = ta.selectionEnd; if (typeof s === 'number' && typeof en === 'number' && en > s) { e.preventDefault(); addSelectedUnified(); } } }} placeholder="è²¼ä¸Šæˆ–è¼¸å…¥è¦å”¸å‡ºä¾†çš„æ–‡å­—â€¦ï¼ˆåç™½ã€é›™æ“Šæˆ–æŒ‰ Enter å¯åŠ å…¥ Vocabularyï¼‰" className="w-full h-40 md:h-44 rounded-xl border border-slate-300 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 p-3 resize-vertical bg-slate-50/50" aria-label="è¼¸å…¥è¦æœ—è®€çš„æ–‡å­—" />

                    {/* Preview with synchronized highlight */}
                    <div className="mt-4">
                      <div className="flex items-center justify-between mb-2">
                        <h2 className="font-medium">é è¦½ï¼ˆåŒæ­¥é«˜äº®ï¼‰</h2>
                        <div className="text-xs text-slate-500">æ®µè½æ•¸ï¼š{chunks.length} Â· é€²åº¦ï¼š{currentIndex >= 0 ? currentIndex + 1 : 0}/{chunks.length}</div>
                      </div>
                      <div className="max-h-64 overflow-auto rounded-xl border border-slate-200 bg-slate-50 p-3 space-y-2" data-testid="preview-pane" tabIndex={0} onKeyDown={(e) => { if (e.key === 'Enter') { const s = (window.getSelection && window.getSelection().toString().trim()); if (s) { e.preventDefault(); addSelectedUnified(); } } }}>
                        {chunks.length === 0 && (<div className="text-sm text-slate-500">ç„¡æ–‡å­—ï¼Œè«‹åœ¨ä¸Šæ–¹è¼¸å…¥å…§å®¹ã€‚</div>)}
                        {chunks.map((c, i) => {
                          const active = i === currentIndex && (isSpeaking || isPaused);
                          return (
                            <div key={i} ref={chunkRefs.current[i]} data-active={active ? 'true' : 'false'} className={`text-sm leading-relaxed rounded-lg border p-2 cursor-text select-text ${active ? 'bg-yellow-50 border-yellow-300 ring-2 ring-yellow-200' : 'bg-white border-slate-200 hover:bg-slate-50'}`}
                              onClick={(e) => { if (e.detail > 1) return; const hasSel = (window.getSelection && window.getSelection().toString().trim().length > 0); if (hasSel) return; speakFromIndex(i); }}
                              onDoubleClick={(e) => { e.preventDefault(); e.stopPropagation(); addSelectedUnified(); }}
                              title={active ? 'æ­£åœ¨æœ—è®€ï¼›å¯åç™½æˆ–é›™æ“Šé¸å­—ï¼ˆæ–°å¢å–®å­—ï¼‰ï¼Œæˆ–é»æ“Šå¾æ­¤æ®µé‡æ’­' : 'å¯åç™½æˆ–é›™æ“Šé¸å­—ï¼ˆæ–°å¢å–®å­—ï¼‰ï¼›é»æ“Šå¾é€™ä¸€æ®µé–‹å§‹æœ—è®€'}>
                              <span className="opacity-60 mr-2">[{i + 1}]</span>
                              <span>{c}</span>
                            </div>
                          );
                        })}
                      </div>
                      {notice && <div className="mt-2 text-xs text-emerald-700 bg-emerald-50 border border-emerald-200 rounded-lg px-2 py-1">{notice}</div>}
                    </div>
                  </div>
                </div>

                {/* Right: Controls + AI Settings */}
                <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-4">
                  <div className="space-y-4">
                    <div>
                      <label className="block font-medium mb-1">èªéŸ³ï¼ˆVoiceï¼‰</label>
                      <select value={voiceURI} onChange={(e) => setVoiceURI(e.target.value)} className="w-full rounded-xl border border-slate-300 p-2 focus:outline-none focus:ring-2 focus:ring-indigo-400" aria-label="é¸æ“‡èªéŸ³">
                        {voices.length === 0 && <option>ï¼ˆæ­£åœ¨è¼‰å…¥å¯ç”¨èªéŸ³â€¦ï¼‰</option>}
                        {voices.map((v) => (<option key={v.voiceURI || v.name} value={v.voiceURI || v.name}>{v.name} â€” {v.lang}</option>))}
                      </select>
                      {selectedVoice && (<div className="mt-1 text-xs text-slate-500">ç›®å‰ï¼š{selectedVoice.name}ï¼ˆ{selectedVoice.lang}ï¼‰</div>)}
                    </div>

                    <div>
                      <label htmlFor="rate" className="block font-medium mb-1">èªé€Ÿï¼ˆ{rate.toFixed(2)}Ã—ï¼‰</label>
                      <input id="rate" type="range" min={RATE_MIN} max={RATE_MAX} step={0.05} value={rate} onChange={(e) => handleRateChange(parseFloat(e.target.value))} className="w-full" aria-label="èª¿æ•´èªé€Ÿ" />
                      <div className="flex justify-between text-xs text-slate-500"><span>æ›´æ…¢ï¼ˆ{RATE_MIN}Ã—ï¼‰</span><span>æ›´å¿«ï¼ˆ{RATE_MAX}Ã—ï¼‰</span></div>
                      <div className="flex flex-wrap gap-2 mt-2">
                        <button onClick={() => handleRateChange(0.25)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200 text-xs" type="button">è¶…æ…¢ 0.25Ã—</button>
                        <button onClick={() => handleRateChange(0.5)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200 text-xs" type="button">æ…¢é€ŸÃ—2ï¼ˆ0.5Ã—ï¼‰</button>
                        <button onClick={() => handleRateChange(1.0)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200 text-xs" type="button">æ­£å¸¸ 1.0Ã—</button>
                        <button onClick={() => handleRateChange(1.5)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200 text-xs" type="button">1.5Ã—</button>
                        <button onClick={() => handleRateChange(2.0)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200 text-xs" type="button">2.0Ã—</button>
                      </div>
                    </div>

                    <div className="flex gap-2 pt-2">
                      <button onClick={speak} disabled={!supported || !text.trim()} className="flex-1 px-4 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700 disabled:opacity-40 disabled:cursor-not-allowed" aria-label="é–‹å§‹æœ—è®€">â–¶ï¸ æœ—è®€</button>
                      {isSpeaking ? (
                        <button onClick={pause} className="px-4 py-2 rounded-xl bg-slate-100 hover:bg-slate-200" aria-label="æš«åœæœ—è®€">â¸ æš«åœ</button>
                      ) : isPaused ? (
                        <button onClick={resume} className="px-4 py-2 rounded-xl bg-slate-100 hover:bg-slate-200" aria-label="ç¹¼çºŒæœ—è®€">â¯ ç¹¼çºŒ</button>
                      ) : (
                        <button disabled className="px-4 py-2 rounded-xl bg-slate-50 text-slate-400 border border-slate-200" aria-disabled>â¸ æš«åœ</button>
                      )}
                      <button onClick={cancelAll} className="px-4 py-2 rounded-xl bg-slate-100 hover:bg-slate-200" aria-label="åœæ­¢æœ—è®€">â¹ åœæ­¢</button>
                    </div>

                    {(isSpeaking || isPaused) && (<div className="text-xs text-slate-500">é€²åº¦ï¼š{currentIndex + 1}/{chunks.length}</div>)}

                    {/* AI Settings */}
                    <div className="pt-2 border-t border-slate-200">
                      <details className="rounded-xl bg-slate-50 p-3">
                        <summary className="cursor-pointer select-none font-medium">AI è¨­å®šï¼ˆå¯é¸ï¼‰</summary>
                        <div className="mt-3 space-y-2 text-sm">
                          <label className="block">æä¾›è€…
                            <select value={aiProvider} onChange={(e) => setAiProvider(e.target.value)} className="mt-1 w-full rounded border p-1">
                              <option value="none">ä¸ä½¿ç”¨ï¼ˆåƒ…å­—å…¸å‚™æ´ï¼‰</option>
                              <option value="openai">OpenAIï¼ˆéœ€ API Keyï¼‰</option>
                            </select>
                          </label>
                          {aiProvider === 'openai' && (<>
                            <label className="block">API Key
                              <input type="password" value={aiKey} onChange={(e) => setAiKey(e.target.value)} placeholder="sk-..." className="mt-1 w-full rounded border p-1" />
                            </label>
                            <label className="block">Model
                              <input type="text" value={aiModel} onChange={(e) => setAiModel(e.target.value)} className="mt-1 w-full rounded border p-1" />
                            </label>
                            <div className="text-[11px] text-slate-500">æé†’ï¼šæŠŠ Key æ”¾åœ¨å‰ç«¯æœ‰å¤–æµé¢¨éšªï¼Œåƒ…ä¾›å€‹äººä½¿ç”¨ã€‚æ­£å¼ä¸Šç·šè«‹æ”¹ç”¨å¾Œç«¯ä»£ç†ã€‚</div>
                          </>)}
                        </div>
                      </details>
                    </div>
                  </div>
                </div>
              </div>

              {/* Vocabulary Section */}
              <div className="mt-6 bg-white rounded-2xl shadow-sm border border-slate-200 p-4">
                <div className="flex items-center justify-between mb-3">
                  <h2 className="font-medium">å–®å­—èˆ‡è§£é‡‹ï¼ˆVocabularyï¼‰</h2>
                  <div className="flex items-center gap-2 text-sm">
                    <button onClick={() => playAllWords(2, false)} className="px-3 py-1.5 rounded-full bg-indigo-600 text-white hover:bg-indigo-700">â–¶ï¸ å…¨éƒ¨æ’­æ”¾ï¼ˆæ¯è© 2xï¼‰</button>
                  </div>
                </div>

                {/* Add row */}
                <VocabEditor addVocab={addVocab} />

                {/* List */}
                <VocabList vocab={vocab} playWord={playWord} removeVocab={removeVocab} />
              </div>

              <div className="mt-6 bg-white rounded-2xl shadow-sm border border-slate-200 p-4">
                <h2 className="font-medium mb-2">ä½¿ç”¨èªªæ˜</h2>
                <ul className="list-disc list-inside text-sm text-slate-600 space-y-1">
                  <li>åœ¨ç·¨è¼¯æ¡†æˆ–é è¦½å€<strong>é›™æ“Š</strong>å–®å­—ï¼ˆæˆ–åç™½é¸å–ã€<strong>æŒ‰ Enter</strong>ï¼‰å³å¯åŠ å…¥ Vocabularyï¼Œä¸¦è‡ªå‹•å˜—è©¦ç”¨ AI ç”¢ç”Ÿç¹ä¸­è§£é‡‹ï¼ˆå¤±æ•—å‰‡åƒ…åŠ å…¥å–®å­—ï¼‰ã€‚</li>
                  <li>åŠ å…¥å¾Œæœƒ<strong>è‡ªå‹•å°‡æ–‡ç« èˆ‡æ›´æ–°å¾Œçš„å–®å­—è¡¨ä¸€èµ·å„²å­˜</strong>ï¼ˆæœªå»ºç«‹æ–‡ç« å‰‡æœƒè‡ªå‹•å»ºç«‹ï¼‰ã€‚</li>
                  <li>è¼‰å…¥æ–‡ç« æ™‚æœƒå¸¶å‡ºè©²ç¯‡çš„å°ˆå±¬å–®å­—è¡¨ï¼›æœ—è®€æ”¯æ´åŒæ­¥é«˜äº®èˆ‡æ®µè½é»é¸æ’­æ”¾ã€‚</li>
                </ul>
              </div>

              <footer className="py-6 text-center text-xs text-slate-400">Â© {new Date().getFullYear()} ReadBuddyï½œæœ—è®€å¤¥ä¼´</footer>
            </div>
          </div>
        );
      }

      // --- Vocabulary Components ---
      function VocabEditor({ addVocab }) {
        const [term, setTerm] = React.useState("");
        const [definition, setDefinition] = React.useState("");
        return (
          <div className="grid grid-cols-1 md:grid-cols-5 gap-2">
            <input value={term} onChange={(e) => setTerm(e.target.value)} placeholder="å–®å­—ï¼ˆå¿…å¡«ï¼‰" className="md:col-span-2 rounded-lg border border-slate-300 p-2 bg-slate-50/50 focus:outline-none focus:ring-2 focus:ring-indigo-400" aria-label="å–®å­—" />
            <input value={definition} onChange={(e) => setDefinition(e.target.value)} placeholder="è§£é‡‹ï¼ˆé¸å¡«ï¼‰" className="md:col-span-2 rounded-lg border border-slate-300 p-2 bg-slate-50/50 focus:outline-none focus:ring-2 focus:ring-indigo-400" aria-label="è§£é‡‹" />
            <button type="button" onClick={() => { const ok = addVocab(term, definition); if (ok) { setTerm(""); setDefinition(""); } }} className="rounded-lg border border-slate-300 px-3 py-2 bg-slate-100 hover:bg-slate-200">æ–°å¢</button>
          </div>
        );
      }

      function VocabList({ vocab, playWord, removeVocab }) {
        return (
          <div className="mt-3 divide-y divide-slate-200">
            {vocab.length === 0 ? (
              <div className="text-sm text-slate-500">å°šæœªæ–°å¢ä»»ä½•å–®å­—ã€‚å¯åœ¨æ–‡ç« æˆ–é è¦½ä¸­åç™½ã€é›™æ“Šæˆ–æŒ‰ Enter æ–°å¢ã€‚</div>
            ) : (
              vocab.map((item) => (
                <div key={item.id} className="py-2 flex items-center gap-3">
                  <div className="flex-1 min-w-0">
                    <div className="font-medium truncate">{item.term}</div>
                    {item.definition && <div className="text-sm text-slate-600 truncate">{item.definition}</div>}
                  </div>
                  <div className="flex items-center gap-2 text-sm">
                    <button onClick={() => playWord(item.term, 1, false, item.definition)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">â–¶ï¸ 1x</button>
                    <button onClick={() => playWord(item.term, 3, false, item.definition)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">ğŸ” 3x</button>
                    <button onClick={() => playWord(item.term, 5, false, item.definition)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">ğŸ” 5x</button>
                    <button onClick={() => playWord(item.term, 1, true, item.definition)} className="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200" title="æ’­æ”¾ å–®å­— + è§£é‡‹">è©+è§£é‡‹</button>
                    <button onClick={() => removeVocab(item.id)} className="px-2 py-1 rounded bg-red-50 hover:bg-red-100 text-red-700 border border-red-200">åˆªé™¤</button>
                  </div>
                </div>
              ))
            )}
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>
